<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OmniPDF</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Babel for on-the-fly JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1; 
      }
      ::-webkit-scrollbar-thumb {
        background: #888; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #555; 
      }
      .aspect-a4 {
        aspect-ratio: 1 / 1.414;
      }
      /* Drag and Drop Styles */
      .thumbnail-card {
        transition: all 0.2s ease;
      }
      .thumbnail-card.dragging {
        opacity: 0.5;
        transform: scale(0.95);
      }
      .thumbnail-card.drag-over {
        border-color: #3b82f6;
        transform: scale(1.05);
      }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0?external=react",
        "pdf-lib": "https://esm.sh/pdf-lib@1.17.1",
        "@pdf-lib/fontkit": "https://esm.sh/@pdf-lib/fontkit@1.1.1",
        "mammoth": "https://esm.sh/mammoth@1.6.0",
        "pdfjs-dist": "https://esm.sh/pdfjs-dist@3.11.174",
        "jszip": "https://esm.sh/jszip@3.10.1",
        "xlsx": "https://cdn.sheetjs.com/xlsx-0.20.0/package/xlsx.mjs"
      }
    }
    </script>
    <!-- Load PDF.js Worker definition -->
    <script src="https://esm.sh/pdfjs-dist@3.11.174/build/pdf.worker.min.js" type="module"></script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-slate-50 text-slate-900 antialiased">
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { FileText, Layers, Scissors, Move, Eye, UploadCloud, Languages, FileDigit, Download, ArrowLeft, ArrowRight, X, CheckCircle, AlertCircle, Loader2, GripVertical, Check } from 'lucide-react';
      import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
      import fontkit from '@pdf-lib/fontkit';
      import * as pdfjsLibImport from 'pdfjs-dist';
      import mammoth from 'mammoth';
      import JSZip from 'jszip';
      import * as XLSX from 'xlsx';

      // --- 1. PDF.js WORKER SETUP ---
      const pdfjsLib = pdfjsLibImport.default || pdfjsLibImport;
      if (pdfjsLib.GlobalWorkerOptions) {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://esm.sh/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
      } else if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
          window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://esm.sh/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
      }

      // --- 2. GLOBAL ASSETS CACHE ---
      let cachedFontBytes = null;
      let isFontLoading = false;
      let fontLoadPromise = null;

      const fetchFontInternal = async () => {
        // Try multiple CDNs in case one fails
        const urls = [
            'https://cdn.jsdelivr.net/npm/firefly-sung@1.0.0/FireflySung.ttf',
            'https://unpkg.com/firefly-sung@1.0.0/FireflySung.ttf'
        ];
        
        for (const url of urls) {
            try {
                // console.log(`Attempting to load font from: ${url}`);
                const res = await fetch(url);
                if (!res.ok) throw new Error(`Status ${res.status}`);
                const buffer = await res.arrayBuffer();
                console.log("CJK font loaded successfully.");
                return buffer;
            } catch (e) {
                // console.warn(`Failed to load font from ${url}`, e);
            }
        }
        throw new Error("All font sources failed");
      };

      const loadCJKFont = async () => {
        if (cachedFontBytes) return cachedFontBytes;
        if (fontLoadPromise) return fontLoadPromise;

        isFontLoading = true;
        
        fontLoadPromise = fetchFontInternal()
            .then(buffer => {
                cachedFontBytes = buffer;
                isFontLoading = false;
                return buffer;
            })
            .catch(err => {
                isFontLoading = false;
                fontLoadPromise = null; // allow retry
                throw err;
            });
            
        return fontLoadPromise;
      };

      // --- 3. HELPER FUNCTIONS ---

      // Helper: Parse Page Ranges (e.g. "1-3, 5") -> Set of 0-based indices
      function parsePageRanges(rangeStr, maxPages) {
        const pages = new Set();
        const parts = rangeStr.split(',');

        parts.forEach(part => {
          const range = part.trim().split('-');
          if (range.length === 1) {
            const p = parseInt(range[0]);
            if (!isNaN(p) && p >= 1 && p <= maxPages) pages.add(p - 1);
          } else if (range.length === 2) {
            const start = parseInt(range[0]);
            const end = parseInt(range[1]);
            if (!isNaN(start) && !isNaN(end)) {
              for (let i = start; i <= end; i++) {
                if (i >= 1 && i <= maxPages) pages.add(i - 1);
              }
            }
          }
        });
        return pages;
      }

      // Helper: Indices to Range String (e.g. [0, 1, 4] -> "1-2, 5")
      function indicesToRangeString(indices) {
        if (indices.length === 0) return "";
        const sorted = [...indices].sort((a, b) => a - b);
        const parts = [];
        if (sorted.length === 0) return "";
        
        let start = sorted[0];
        let prev = sorted[0];

        for (let i = 1; i < sorted.length; i++) {
            if (sorted[i] === prev + 1) {
                prev = sorted[i];
            } else {
                parts.push(start === prev ? `${start + 1}` : `${start + 1}-${prev + 1}`);
                start = sorted[i];
                prev = sorted[i];
            }
        }
        parts.push(start === prev ? `${start + 1}` : `${start + 1}-${prev + 1}`);
        return parts.join(", ");
      }

      // Helper: Parse Page Order (e.g. "3, 1, 2") -> Array of 0-based indices
      function parsePageOrder(orderStr, maxPages) {
        const indices = [];
        const parts = orderStr.split(',');
        parts.forEach(part => {
          const p = parseInt(part.trim());
          if (!isNaN(p) && p >= 1 && p <= maxPages) {
            indices.push(p - 1);
          }
        });
        return indices;
      }

      // --- 4. SERVICES (PDF LOGIC) ---
      
      // Extract Text from PPTX Slide XML
      async function extractTextFromPPTX(arrayBuffer) {
        const zip = await JSZip.loadAsync(arrayBuffer);
        const slideTexts = [];
        const slideFiles = Object.keys(zip.files).filter(fileName => 
          fileName.match(/ppt\/slides\/slide\d+\.xml/)
        );
        slideFiles.sort((a, b) => {
           const matchA = a.match(/slide(\d+)\.xml/);
           const matchB = b.match(/slide(\d+)\.xml/);
           if (!matchA || !matchB) return 0;
           return parseInt(matchA[1]) - parseInt(matchB[1]);
        });
        for (const fileName of slideFiles) {
           const xmlStr = await zip.files[fileName].async("string");
           const parser = new DOMParser();
           const xmlDoc = parser.parseFromString(xmlStr, "text/xml");
           const textNodes = xmlDoc.getElementsByTagName("a:t");
           let slideContent = "";
           for (let i = 0; i < textNodes.length; i++) {
              slideContent += textNodes[i].textContent + "\n";
           }
           if (!slideContent.trim()) slideContent = "[Empty Slide]";
           slideTexts.push(slideContent);
        }
        return slideTexts;
      }

      // Extract Text from Excel
      async function extractTextFromExcel(arrayBuffer) {
         const workbook = XLSX.read(arrayBuffer, { type: 'array' });
         const sheets = [];
         workbook.SheetNames.forEach(sheetName => {
            const worksheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            let text = `Sheet: ${sheetName}\n\n`;
            json.forEach(row => {
               text += row.join("  |  ") + "\n";
            });
            sheets.push(text);
         });
         return sheets;
      }

      const getPDFThumbnails = async (file) => {
        const fileBuffer = await file.arrayBuffer();
        try {
            const loadingTask = pdfjsLib.getDocument({ data: fileBuffer });
            const pdf = await loadingTask.promise;
            const numPages = pdf.numPages;
            const thumbnails = [];
            
            for (let i = 1; i <= numPages; i++) {
              const page = await pdf.getPage(i);
              const viewport = page.getViewport({ scale: 0.25 });
              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              await page.render({ canvasContext: context, viewport: viewport }).promise;
              thumbnails.push({
                pageIndex: i - 1,
                dataUrl: canvas.toDataURL(),
                originalIndex: i, 
                id: `page-${i}-${Math.random().toString(36).substr(2,9)}`
              });
            }
            return thumbnails;
        } catch(e) {
            console.error("PDF Render error:", e);
            throw e;
        }
      };

      const mergePdfs = async (files) => {
        const mergedPdf = await PDFDocument.create();
        for (const fileObj of files) {
          if (fileObj.type !== 'pdf') continue;
          const fileBuffer = await fileObj.file.arrayBuffer();
          const pdf = await PDFDocument.load(fileBuffer);
          const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
          copiedPages.forEach((page) => mergedPdf.addPage(page));
        }
        return await mergedPdf.save();
      };

      const splitPdf = async (file, pageIndices) => {
        const fileBuffer = await file.file.arrayBuffer();
        const srcPdf = await PDFDocument.load(fileBuffer);
        const newPdf = await PDFDocument.create();
        const indices = pageIndices.map(Number);
        const copiedPages = await newPdf.copyPages(srcPdf, indices);
        copiedPages.forEach((page) => newPdf.addPage(page));
        return await newPdf.save();
      };

      const reorderPdf = async (file, pageIndices) => {
        return splitPdf(file, pageIndices);
      };

      const convertOfficeToPdfMock = async (file) => {
        const pdfDoc = await PDFDocument.create();
        pdfDoc.registerFontkit(fontkit);
        let font;
        let fontName = 'Standard';
        try {
           let fontBytes = cachedFontBytes;
           if (!fontBytes) {
             fontBytes = await loadCJKFont();
           }
           font = await pdfDoc.embedFont(fontBytes);
           fontName = 'FireflySung';
        } catch (e) {
           console.warn("Could not load Chinese font, falling back to Helvetica.", e);
           font = await pdfDoc.embedFont(StandardFonts.Helvetica);
           fontName = 'Helvetica';
        }
        let pagesContent = [];
        const arrayBuffer = await file.file.arrayBuffer();
        try {
          if (file.type === 'word') {
             const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
             pagesContent = [result.value || ""];
          } else if (file.type === 'ppt') {
             pagesContent = await extractTextFromPPTX(arrayBuffer);
          } else if (file.type === 'excel') {
             pagesContent = await extractTextFromExcel(arrayBuffer);
          } else {
             pagesContent = [`Unsupported format: ${file.type}`];
          }
        } catch (e) {
           pagesContent = [`Error extracting content: ${e.message}`];
        }

        const fontSize = 12;
        const margin = 50;
        const lineHeight = 16;
        for (let sectionIndex = 0; sectionIndex < pagesContent.length; sectionIndex++) {
           let textContent = pagesContent[sectionIndex];
           if (!textContent) continue;
           if (fontName === 'Helvetica') {
              textContent = textContent.replace(/[^\u0000-\u00FF]/g, "?");
           }
           let page = pdfDoc.addPage();
           const { width, height } = page.getSize();
           let y = height - margin;
           if (file.type === 'ppt') {
              page.drawText(`Slide ${sectionIndex + 1}`, { x: margin, y: y, size: 14, font, color: rgb(0, 0, 1) });
              y -= 30;
           }
           const lines = textContent.split(/\r?\n/);
           for (const line of lines) {
              if (y < margin) {
                page = pdfDoc.addPage();
                y = height - margin;
              }
              const cleanLine = line.length > 90 ? line.substring(0, 90) + '...' : line;
              try {
                page.drawText(cleanLine, { x: margin, y, size: fontSize, font });
              } catch (err) { }
              y -= lineHeight;
           }
        }
        if (pdfDoc.getPageCount() === 0) {
           const page = pdfDoc.addPage();
           page.drawText("Empty Document or Conversion Failed", { x: 50, y: 500, size: 12, font: await pdfDoc.embedFont(StandardFonts.Helvetica) });
        }
        return await pdfDoc.save();
      };

      // --- 5. CONSTANTS & TRANSLATIONS ---
      const TRANSLATIONS = {
        en: {
          title: "OmniPDF",
          subtitle: "Secure, Serverless PDF Tools running entirely in your browser.",
          dragDrop: "Drag & drop files here, or",
          browse: "browse files",
          footerSecure: "Browser Local Processing (No Uploads to Server)",
          tools: {
            convert: "Office to PDF",
            merge: "Merge PDFs",
            split: "Split PDF",
            reorder: "Organize Pages"
          },
          uploadHints: {
            pdf: "Only PDF files supported",
            office: "Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
          },
          actions: {
            download: "Download",
            clear: "Clear All",
            processing: "Processing...",
            downloadingResources: "Loading fonts...",
            convertNow: "Convert to PDF",
            mergeNow: "Merge Files",
            splitNow: "Extract Selected Pages",
            saveOrder: "Save New Order",
            preview: "Preview",
            back: "Back to Tools",
            remove: "Remove",
            selectAll: "Select All",
            deselectAll: "Deselect All"
          },
          warnings: {
            convertNote: "Note: Text extraction runs locally. Layouts will be simplified. Only supports English/Latin documents."
          },
          errors: {
            unsupported: "Unsupported file format.",
            onlyPdf: "This tool only accepts PDF files.",
            needTwoFiles: "Please upload at least 2 PDF files to merge.",
            fontError: "Font loading failed. Retrying...",
            noSelection: "Please select at least one page to extract."
          },
          labels: {
            pageRange: "Select pages below or type ranges (e.g. 1-3, 5):",
            pageOrder: "Drag pages below or type order (e.g. 3, 1, 2):",
            convertingFont: "Downloading fonts & converting..."
          }
        },
        zh: {
          title: "OmniPDF",
          subtitle: "安全、无服务器的 PDF 工具，完全在您的浏览器中运行。",
          dragDrop: "拖放文件到此处，或",
          browse: "浏览文件",
          footerSecure: "浏览器本地处理（无需上传到服务器）",
          tools: {
            convert: "Office 转 PDF",
            merge: "合并 PDF",
            split: "拆分 PDF",
            reorder: "页面重组"
          },
          uploadHints: {
            pdf: "仅支持 PDF 文件",
            office: "支持 Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
          },
          actions: {
            download: "下载文件",
            clear: "清空",
            processing: "处理中...",
            downloadingResources: "正在加载字体...",
            convertNow: "转换为 PDF",
            mergeNow: "合并文件",
            splitNow: "提取选中页面",
            saveOrder: "保存新顺序",
            preview: "预览",
            back: "返回工具箱",
            remove: "移除",
            selectAll: "全选",
            deselectAll: "取消全选"
          },
          warnings: {
            convertNote: "注意：文本提取在本地运行。布局将被简化。仅支持英语/拉丁语系文档。"
          },
          errors: {
            unsupported: "不支持的文件格式。",
            onlyPdf: "此工具仅支持 PDF 文件。",
            needTwoFiles: "请至少上传 2 个 PDF 文件进行合并。",
            fontError: "字体加载失败，正在重试...",
            noSelection: "请至少选择一页进行提取。"
          },
          labels: {
            pageRange: "在下方点击选择页面或输入范围 (如 1-3, 5):",
            pageOrder: "在下方拖拽排序或输入顺序 (如 3, 1, 2):",
            convertingFont: "正在下载字体并转换..."
          }
        },
        ja: {
            title: "OmniPDF",
            subtitle: "ブラウザで動作する安全なサーバーレスPDFツール。",
            dragDrop: "ファイルをここにドラッグ、または",
            browse: "ファイルを選択",
            footerSecure: "ブラウザ内ローカル処理（サーバー送信なし）",
            tools: {
              convert: "OfficeからPDF",
              merge: "PDF結合",
              split: "PDF分割",
              reorder: "ページ整理"
            },
            uploadHints: {
              pdf: "PDFファイルのみ対応",
              office: "Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
            },
            actions: {
              download: "ダウンロード",
              clear: "すべてクリア",
              processing: "処理中...",
              downloadingResources: "フォント読み込み中...",
              convertNow: "PDFに変換",
              mergeNow: "ファイルを結合",
              splitNow: "選択ページを抽出",
              saveOrder: "順序を保存",
              preview: "プレビュー",
              back: "ツールに戻る",
              remove: "削除",
              selectAll: "すべて選択",
              deselectAll: "選択解除"
            },
            warnings: {
              convertNote: "注：テキスト抽出はローカルで行われます。レイアウトは簡素化されます。英語/ラテン語のドキュメントのみ対応。"
            },
            errors: {
              unsupported: "未対応の形式です。",
              onlyPdf: "PDFファイルのみ受け付けます。",
              needTwoFiles: "結合するには2つ以上のPDFをアップロードしてください。",
              fontError: "フォント読み込み失敗。再試行中...",
              noSelection: "抽出するページを少なくとも1つ選択してください。"
            },
            labels: {
              pageRange: "ページを選択または範囲入力 (例: 1-3, 5):",
              pageOrder: "ドラッグまたは順序入力 (例: 3, 1, 2):",
              convertingFont: "フォントをダウンロードして変換中..."
            }
        },
        fr: {
          title: "OmniPDF",
          subtitle: "Outils PDF sécurisés et sans serveur s'exécutant dans votre navigateur.",
          dragDrop: "Glissez les fichiers ici, ou",
          browse: "parcourir",
          footerSecure: "Traitement local (Pas de transfert serveur)",
          tools: {
            convert: "Office en PDF",
            merge: "Fusionner PDF",
            split: "Diviser PDF",
            reorder: "Organiser pages"
          },
          uploadHints: {
            pdf: "Fichiers PDF uniquement",
            office: "Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
          },
          actions: {
            download: "Télécharger",
            clear: "Tout effacer",
            processing: "Traitement...",
            downloadingResources: "Chargement polices...",
            convertNow: "Convertir en PDF",
            mergeNow: "Fusionner",
            splitNow: "Extraire pages",
            saveOrder: "Sauvegarder l'ordre",
            preview: "Aperçu",
            back: "Retour",
            remove: "Supprimer",
            selectAll: "Tout sélectionner",
            deselectAll: "Tout désélectionner"
          },
          warnings: {
            convertNote: "Note : Extraction locale. Mise en page simplifiée. Supporte doc anglais/latin uniquement."
          },
          errors: {
            unsupported: "Format non supporté.",
            onlyPdf: "Outil pour PDF uniquement.",
            needTwoFiles: "Uploadez au moins 2 fichiers PDF.",
            fontError: "Erreur police. Réessai...",
            noSelection: "Sélectionnez au moins une page."
          },
          labels: {
            pageRange: "Sélectionnez ou tapez (ex: 1-3, 5):",
            pageOrder: "Glissez ou tapez (ex: 3, 1, 2):",
            convertingFont: "Téléchargement police et conversion..."
          }
        },
        es: {
          title: "OmniPDF",
          subtitle: "Herramientas PDF seguras y sin servidor en su navegador.",
          dragDrop: "Arrastre archivos aquí, o",
          browse: "buscar",
          footerSecure: "Procesamiento local (Sin subidas al servidor)",
          tools: {
            convert: "Office a PDF",
            merge: "Unir PDF",
            split: "Dividir PDF",
            reorder: "Organizar páginas"
          },
          uploadHints: {
            pdf: "Solo archivos PDF",
            office: "Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
          },
          actions: {
            download: "Descargar",
            clear: "Limpiar todo",
            processing: "Procesando...",
            downloadingResources: "Cargando fuentes...",
            convertNow: "Convertir a PDF",
            mergeNow: "Unir archivos",
            splitNow: "Extraer páginas",
            saveOrder: "Guardar orden",
            preview: "Vista previa",
            back: "Volver",
            remove: "Eliminar",
            selectAll: "Seleccionar todo",
            deselectAll: "Deseleccionar todo"
          },
          warnings: {
            convertNote: "Nota: Extracción local. Diseños simplificados. Solo docs en inglés/latín."
          },
          errors: {
            unsupported: "Formato no soportado.",
            onlyPdf: "Solo archivos PDF.",
            needTwoFiles: "Suba al menos 2 archivos PDF.",
            fontError: "Error de fuente. Reintentando...",
            noSelection: "Seleccione al menos una página."
          },
          labels: {
            pageRange: "Seleccione o escriba (ej. 1-3, 5):",
            pageOrder: "Arrastre o escriba (ej. 3, 1, 2):",
            convertingFont: "Descargando fuente y convirtiendo..."
          }
        },
        de: {
          title: "OmniPDF",
          subtitle: "Sichere, serverlose PDF-Tools direkt im Browser.",
          dragDrop: "Dateien hierher ziehen, oder",
          browse: "durchsuchen",
          footerSecure: "Lokale Verarbeitung (Kein Upload)",
          tools: {
            convert: "Office in PDF",
            merge: "PDFs verbinden",
            split: "PDF teilen",
            reorder: "Seiten ordnen"
          },
          uploadHints: {
            pdf: "Nur PDF-Dateien",
            office: "Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
          },
          actions: {
            download: "Herunterladen",
            clear: "Alles löschen",
            processing: "Verarbeitung...",
            downloadingResources: "Lade Schriftarten...",
            convertNow: "In PDF konvertieren",
            mergeNow: "Dateien verbinden",
            splitNow: "Seiten extrahieren",
            saveOrder: "Reihenfolge speichern",
            preview: "Vorschau",
            back: "Zurück",
            remove: "Entfernen",
            selectAll: "Alle auswählen",
            deselectAll: "Auswahl aufheben"
          },
          warnings: {
            convertNote: "Hinweis: Lokale Extraktion. Layouts vereinfacht. Nur Englisch/Latein."
          },
          errors: {
            unsupported: "Format nicht unterstützt.",
            onlyPdf: "Nur PDF-Dateien.",
            needTwoFiles: "Mindestens 2 PDFs hochladen.",
            fontError: "Schriftfehler. Wiederhole...",
            noSelection: "Mindestens eine Seite auswählen."
          },
          labels: {
            pageRange: "Auswählen oder eingeben (z.B. 1-3, 5):",
            pageOrder: "Ziehen oder eingeben (z.B. 3, 1, 2):",
            convertingFont: "Lade Schrift und konvertiere..."
          }
        },
        it: {
          title: "OmniPDF",
          subtitle: "Strumenti PDF sicuri e serverless nel tuo browser.",
          dragDrop: "Trascina i file qui, o",
          browse: "sfoglia",
          footerSecure: "Elaborazione locale (Nessun caricamento)",
          tools: {
            convert: "Office in PDF",
            merge: "Unisci PDF",
            split: "Dividi PDF",
            reorder: "Ordina pagine"
          },
          uploadHints: {
            pdf: "Solo file PDF",
            office: "Word (.docx), PowerPoint (.pptx), Excel (.xlsx)"
          },
          actions: {
            download: "Scarica",
            clear: "Pulisci tutto",
            processing: "Elaborazione...",
            downloadingResources: "Caricamento font...",
            convertNow: "Converti in PDF",
            mergeNow: "Unisci file",
            splitNow: "Estrai pagine",
            saveOrder: "Salva ordine",
            preview: "Anteprima",
            back: "Indietro",
            remove: "Rimuovi",
            selectAll: "Seleziona tutto",
            deselectAll: "Deseleziona tutto"
          },
          warnings: {
            convertNote: "Nota: Estrazione locale. Layout semplificati. Solo doc inglese/latino."
          },
          errors: {
            unsupported: "Formato non supportato.",
            onlyPdf: "Solo file PDF.",
            needTwoFiles: "Carica almeno 2 file PDF.",
            fontError: "Errore font. Riprovo...",
            noSelection: "Seleziona almeno una pagina."
          },
          labels: {
            pageRange: "Seleziona o scrivi (es. 1-3, 5):",
            pageOrder: "Trascina o scrivi (es. 3, 1, 2):",
            convertingFont: "Scaricamento font e conversione..."
          }
        }
      };

      const TOOLS_CONFIG = [
        { id: 'convert', icon: FileText, color: 'bg-blue-500' },
        { id: 'merge', icon: Layers, color: 'bg-indigo-500' },
        { id: 'split', icon: Scissors, color: 'bg-rose-500' },
        { id: 'reorder', icon: Move, color: 'bg-orange-500' },
      ];

      // --- 6. COMPONENTS ---
      
      const TopBar = ({ language, setLanguage, title }) => {
        return (
          <div className="w-full h-16 bg-white border-b border-gray-200 flex items-center justify-between px-6 sticky top-0 z-50">
            <div className="flex items-center gap-2">
              <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center text-white">
                <FileDigit size={20} />
              </div>
              <h1 className="text-xl font-bold text-gray-800 tracking-tight">{title}</h1>
            </div>
            
            <div className="relative">
              <Languages size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500 pointer-events-none" />
              <select 
                value={language} 
                onChange={(e) => setLanguage(e.target.value)}
                className="appearance-none bg-gray-100 hover:bg-gray-200 text-gray-700 text-sm font-medium py-1.5 pl-9 pr-8 rounded-full cursor-pointer outline-none focus:ring-2 focus:ring-blue-500 transition-colors border-none"
              >
                <option value="en">English</option>
                <option value="zh">中文</option>
                <option value="ja">日本語</option>
                <option value="fr">Français</option>
                <option value="es">Español</option>
                <option value="de">Deutsch</option>
                <option value="it">Italiano</option>
              </select>
              <div className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-gray-500">
                 <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
              </div>
            </div>
          </div>
        );
      };

      const FileUploader = ({ onFilesSelected, text, accept, multiple = false, hintText }) => {
        const fileInputRef = useRef(null);
        const [isDragging, setIsDragging] = useState(false);
        const processFiles = (fileList) => {
          if (!fileList) return;
          const newFiles = Array.from(fileList).map(f => {
             let type = 'unknown';
             const name = f.name.toLowerCase();
             if (name.endsWith('.pdf')) type = 'pdf';
             else if (name.endsWith('.docx') || name.endsWith('.doc')) type = 'word';
             else if (name.endsWith('.pptx') || name.endsWith('.ppt')) type = 'ppt';
             else if (name.endsWith('.xlsx') || name.endsWith('.xls')) type = 'excel';
             return {
                id: Math.random().toString(36).substr(2, 9),
                file: f,
                type: type,
                previewUrl: type === 'pdf' ? URL.createObjectURL(f) : undefined
             };
          });
          onFilesSelected(newFiles);
        };
        return (
          <div
            onClick={() => fileInputRef.current?.click()}
            onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
            onDragLeave={(e) => { e.preventDefault(); setIsDragging(false); }}
            onDrop={(e) => { e.preventDefault(); setIsDragging(false); processFiles(e.dataTransfer.files); }}
            className={`w-full h-48 border-2 border-dashed rounded-xl flex flex-col items-center justify-center cursor-pointer transition-all duration-200
              ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-400 hover:bg-gray-50'}`}
          >
            <input type="file" ref={fileInputRef} className="hidden" accept={accept} multiple={multiple} onChange={(e) => processFiles(e.target.files)} />
            <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center mb-4 text-blue-600">
              <UploadCloud size={24} />
            </div>
            <p className="text-gray-600 text-center font-medium">
              {text.dragDrop} <span className="text-blue-600 underline">{text.browse}</span>
            </p>
            <p className="text-gray-400 text-sm mt-2">{hintText}</p>
          </div>
        );
      };

      const ToolWorkspace = ({ tool, t, onBack }) => {
        const [files, setFiles] = useState([]);
        const [isProcessing, setIsProcessing] = useState(false);
        const [statusMessage, setStatusMessage] = useState("");
        const [activePreview, setActivePreview] = useState(null);
        
        // --- State for Split/Reorder ---
        const [sourceThumbnails, setSourceThumbnails] = useState([]); // Master list of pages
        const [displayThumbnails, setDisplayThumbnails] = useState([]); // Reorder list (Visual State)
        const [selectedIndices, setSelectedIndices] = useState(new Set()); // Split selection (Visual State)
        const [paramInput, setParamInput] = useState(""); // Text Input (Shared State)

        const dragItem = useRef(null);
        const dragOverItem = useRef(null);

        useEffect(() => {
          setFiles([]);
          setSourceThumbnails([]);
          setDisplayThumbnails([]);
          setActivePreview(null);
          setStatusMessage("");
          setSelectedIndices(new Set());
          setParamInput("");
        }, [tool]);

        const handleFiles = async (newFiles) => {
          if (tool === 'merge') {
              setFiles(prev => [...prev, ...newFiles]);
          } else {
              setFiles([newFiles[0]]);
              if (newFiles[0].type === 'pdf' && (tool === 'split' || tool === 'reorder')) {
                 setIsProcessing(true);
                 setStatusMessage("Generating thumbnails...");
                 try {
                    const thumbs = await getPDFThumbnails(newFiles[0].file);
                    setSourceThumbnails(thumbs);
                    setDisplayThumbnails(thumbs); // Init with original order
                    if (tool === 'reorder') {
                      setParamInput(thumbs.map(t => t.originalIndex).join(', '));
                    } else if (tool === 'split') {
                      setParamInput(""); // Init empty selection
                    }
                 } catch (e) {
                    console.error("Thumbnail generation failed", e);
                 }
                 setIsProcessing(false);
                 setStatusMessage("");
              }
          }
        };

        const removeFile = (id) => {
          setFiles(files.filter(f => f.id !== id));
          if (activePreview?.id === id) setActivePreview(null);
          if (files.length === 1) {
            setSourceThumbnails([]);
            setDisplayThumbnails([]);
            setSelectedIndices(new Set());
            setParamInput("");
          }
        };

        // --- SPLIT TOOL SYNC LOGIC ---
        const handleSplitInputChange = (e) => {
          const val = e.target.value;
          setParamInput(val);
          // Parse string to Set
          const indices = parsePageRanges(val, sourceThumbnails.length);
          setSelectedIndices(indices);
        };

        const toggleSelection = (index) => {
           const newSet = new Set(selectedIndices);
           if (newSet.has(index)) newSet.delete(index);
           else newSet.add(index);
           setSelectedIndices(newSet);
           // Sync to Input
           setParamInput(indicesToRangeString(Array.from(newSet)));
        };

        const toggleSelectAll = () => {
           if (selectedIndices.size === sourceThumbnails.length) {
              setSelectedIndices(new Set());
              setParamInput("");
           } else {
              const all = new Set(sourceThumbnails.map((_, i) => i));
              setSelectedIndices(all);
              setParamInput(indicesToRangeString(Array.from(all)));
           }
        };

        // --- REORDER TOOL SYNC LOGIC ---
        const handleReorderInputChange = (e) => {
           const val = e.target.value;
           setParamInput(val);
           // Parse "1, 3, 2" -> [0, 2, 1]
           const indices = parsePageOrder(val, sourceThumbnails.length);
           // Reconstruct display thumbnails from source based on input order
           // We assign new random IDs to ensure React renders them correctly even if duplicated
           const newDisplay = indices.map(idx => {
              const source = sourceThumbnails[idx];
              if (!source) return null;
              return { 
                ...source, 
                id: `page-${source.originalIndex}-${Math.random().toString(36).substr(2,9)}` 
              }; 
           }).filter(Boolean);
           setDisplayThumbnails(newDisplay);
        };

        const handleDragStart = (e, index) => {
          dragItem.current = index;
          e.currentTarget.classList.add('dragging');
        };
        const handleDragEnter = (e, index) => {
          dragOverItem.current = index;
          e.currentTarget.classList.add('drag-over');
        };
        const handleDragLeave = (e) => {
           e.currentTarget.classList.remove('drag-over');
        }
        const handleDragEnd = (e) => {
          const listItems = [...displayThumbnails];
          const draggedItemContent = listItems[dragItem.current];
          listItems.splice(dragItem.current, 1);
          listItems.splice(dragOverItem.current, 0, draggedItemContent);
          
          dragItem.current = null;
          dragOverItem.current = null;
          setDisplayThumbnails(listItems);
          
          // Remove styles
          const cards = document.querySelectorAll('.thumbnail-card');
          cards.forEach(card => {
             card.classList.remove('dragging');
             card.classList.remove('drag-over');
          });

          // Sync to Input
          setParamInput(listItems.map(t => t.originalIndex).join(', '));
        };

        const processAction = async () => {
          if (files.length === 0) return;
          setIsProcessing(true);
          setStatusMessage(t.actions.processing);

          try {
            if (tool === 'convert' && !cachedFontBytes) {
               setStatusMessage(t.actions.downloadingResources);
               await loadCJKFont().catch(e => console.error("Bg font load failed, will fallback"));
               setStatusMessage(t.actions.processing);
            }

            let resultBytes = null;
            let filename = 'result.pdf';
            await new Promise(r => setTimeout(r, 50));

            if (tool === 'merge') {
              if (files.length < 2) { alert(t.errors.needTwoFiles); setIsProcessing(false); setStatusMessage(""); return; }
              resultBytes = await mergePdfs(files);
              filename = 'merged-document.pdf';
            } else if (tool === 'split') {
              if (selectedIndices.size === 0) { alert(t.errors.noSelection); setIsProcessing(false); setStatusMessage(""); return; }
              const indices = Array.from(selectedIndices).sort((a, b) => a - b);
              resultBytes = await splitPdf(files[0], indices);
              filename = `extracted-${files[0].file.name}`;
            } else if (tool === 'reorder') {
              // For reorder, we use the order of displayThumbnails
              // We need the original source indices (pageIndex)
              const newOrderIndices = displayThumbnails.map(t => t.pageIndex);
              resultBytes = await reorderPdf(files[0], newOrderIndices);
              filename = `reordered-${files[0].file.name}`;
            } else if (tool === 'convert') {
              resultBytes = await convertOfficeToPdfMock(files[0]);
              filename = `${files[0].file.name.split('.')[0]}.pdf`;
            }

            if (resultBytes) {
              const blob = new Blob([resultBytes], { type: 'application/pdf' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = filename;
              a.click();
              setTimeout(() => URL.revokeObjectURL(url), 1000);
            }
          } catch (error) {
            console.error(error);
            alert('An error occurred during processing.');
          } finally {
            setIsProcessing(false);
            setStatusMessage("");
          }
        };

        const acceptType = tool === 'convert' ? '.doc,.docx,.ppt,.pptx,.xls,.xlsx' : '.pdf';
        const multiple = tool === 'merge';
        const hintText = tool === 'convert' ? t.uploadHints.office : t.uploadHints.pdf;

        return (
          <div className="flex flex-col h-full">
            <div className="mb-6 flex items-center justify-between">
              <button onClick={onBack} className="flex items-center text-gray-500 hover:text-gray-800 transition-colors">
                <ArrowLeft size={20} className="mr-2" />
                {t.actions.back}
              </button>
              <h2 className="text-xl font-semibold text-gray-800 uppercase tracking-wide">
                {t.tools[tool === 'preview' ? 'convert' : tool]}
              </h2>
              <div className="w-20"></div>
            </div>

            <div className="flex-1 flex gap-6 flex-col lg:flex-row">
              <div className="flex-1 flex flex-col gap-4">
                <div className="bg-white rounded-xl shadow-sm border border-gray-100 p-6 flex-1 min-h-[300px] flex flex-col">
                  {files.length === 0 ? (
                     <FileUploader onFilesSelected={handleFiles} text={t} accept={acceptType} multiple={multiple} hintText={hintText} />
                  ) : (
                    <>
                      {/* File Info Header */}
                      <div className="flex items-center justify-between p-4 bg-blue-50 rounded-lg border border-blue-100 mb-4 shrink-0">
                          <div className="flex items-center gap-3 overflow-hidden">
                              <div className="p-2 bg-white rounded-md text-blue-600"><FileText size={24} /></div>
                              <div className="truncate font-medium text-gray-700">{files.length === 1 ? files[0].file.name : `${files.length} Files Selected`}</div>
                          </div>
                          <div className="flex gap-2">
                             {tool === 'merge' && (
                               <button onClick={() => setFiles([])} className="text-red-500 text-sm hover:underline px-2">{t.actions.clear}</button>
                             )}
                             {(files.length === 1 && files[0].type === 'pdf') && (
                                <button onClick={() => setActivePreview(files[0])} className="p-2 hover:bg-blue-100 rounded-full text-blue-600 transition" title={t.actions.preview}><Eye size={18} /></button>
                             )}
                             {tool !== 'merge' && (
                                <button onClick={() => removeFile(files[0].id)} className="p-2 hover:bg-red-100 rounded-full text-red-500 transition"><X size={18} /></button>
                             )}
                          </div>
                       </div>
                       
                       {/* Merge Tool File List */}
                       {tool === 'merge' && (
                          <div className="flex-1 overflow-y-auto min-h-[200px]">
                              <div className="flex flex-col gap-2">
                                  {files.map((f, i) => (
                                      <div key={f.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg border border-gray-200">
                                          <div className="flex items-center gap-3 overflow-hidden flex-1">
                                              <span className="w-6 h-6 rounded-full bg-gray-200 text-gray-600 flex items-center justify-center text-xs font-bold">{i + 1}</span>
                                              <span className="truncate text-sm text-gray-700">{f.file.name}</span>
                                          </div>
                                          <button onClick={() => removeFile(f.id)} className="text-gray-400 hover:text-red-500"><X size={16} /></button>
                                      </div>
                                  ))}
                              </div>
                              <div className="mt-4">
                                  <FileUploader onFilesSelected={handleFiles} text={{...t, dragDrop: "Add more files", browse: "browse"}} accept={acceptType} multiple={true} hintText={hintText} />
                              </div>
                          </div>
                       )}

                       {/* Thumbnails Grid for Split/Reorder */}
                       {(tool === 'split' || tool === 'reorder') && (
                         <div className="flex-1 flex flex-col min-h-[300px]">
                           <div className="flex justify-between items-end mb-3 gap-4">
                              <div className="flex-1">
                                <label className="block text-sm font-medium text-gray-700 mb-1">
                                    {tool === 'split' ? t.labels.pageRange : t.labels.pageOrder}
                                </label>
                                <input 
                                    type="text" 
                                    className="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none font-mono text-sm"
                                    placeholder={tool === 'split' ? "e.g. 1-3, 5" : "e.g. 3, 1, 2"}
                                    value={paramInput}
                                    onChange={tool === 'split' ? handleSplitInputChange : handleReorderInputChange}
                                />
                              </div>
                              {tool === 'split' && (
                                 <button onClick={toggleSelectAll} className="text-blue-600 text-sm hover:underline font-medium mb-2 shrink-0">
                                    {selectedIndices.size === sourceThumbnails.length ? t.actions.deselectAll : t.actions.selectAll}
                                 </button>
                              )}
                           </div>
                           
                           {sourceThumbnails.length === 0 && isProcessing ? (
                              <div className="flex-1 flex items-center justify-center text-gray-400 gap-2">
                                 <Loader2 className="animate-spin" /> Generating previews...
                              </div>
                           ) : (
                              <div className="flex-1 overflow-y-auto p-2 bg-slate-100 rounded-lg border border-gray-200 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 auto-rows-min content-start">
                                 {(tool === 'split' ? sourceThumbnails : displayThumbnails).map((thumb, index) => (
                                    <div 
                                       key={thumb.id}
                                       draggable={tool === 'reorder'}
                                       onDragStart={(e) => tool === 'reorder' && handleDragStart(e, index)}
                                       onDragEnter={(e) => tool === 'reorder' && handleDragEnter(e, index)}
                                       onDragEnd={tool === 'reorder' ? handleDragEnd : undefined}
                                       onDragLeave={tool === 'reorder' ? handleDragLeave : undefined}
                                       onDragOver={(e) => e.preventDefault()}
                                       onClick={() => tool === 'split' && toggleSelection(index)}
                                       className={`
                                          thumbnail-card relative group bg-white p-2 rounded-lg shadow-sm border-2 cursor-pointer select-none
                                          ${tool === 'split' && selectedIndices.has(index) ? 'border-blue-500 ring-2 ring-blue-100' : 'border-transparent hover:border-gray-300'}
                                          ${tool === 'reorder' ? 'cursor-move active:cursor-grabbing' : ''}
                                       `}
                                    >
                                       <div className="relative aspect-[1/1.414] bg-gray-50 mb-2 overflow-hidden rounded border border-gray-100">
                                          <img src={thumb.dataUrl} className="w-full h-full object-contain pointer-events-none" />
                                          {tool === 'split' && selectedIndices.has(index) && (
                                             <div className="absolute inset-0 bg-blue-500/20 flex items-center justify-center backdrop-blur-[1px]">
                                                <div className="bg-blue-500 text-white rounded-full p-1 shadow-md">
                                                   <Check size={20} />
                                                </div>
                                             </div>
                                          )}
                                       </div>
                                       <div className="flex justify-between items-center px-1">
                                          <span className="text-xs font-semibold text-gray-500 bg-gray-100 px-2 py-0.5 rounded">
                                             Pg {thumb.originalIndex}
                                          </span>
                                          {tool === 'reorder' && <GripVertical size={14} className="text-gray-300" />}
                                       </div>
                                    </div>
                                 ))}
                              </div>
                           )}
                         </div>
                       )}

                       {/* Action Button */}
                       <div className="mt-6 pt-4 border-t border-gray-100">
                          {tool === 'convert' && (
                              <div className="mb-4 p-3 bg-amber-50 border border-amber-200 rounded-lg flex items-start gap-2 text-sm text-amber-800">
                                  <AlertCircle size={16} className="mt-0.5 shrink-0" />
                                  <p>{t.warnings.convertNote}</p>
                              </div>
                          )}

                          <button onClick={processAction} disabled={isProcessing || (tool === 'split' && selectedIndices.size === 0)} className={`w-full py-3 rounded-lg font-semibold text-white flex items-center justify-center gap-2 transition-all shadow-md ${isProcessing || (tool === 'split' && selectedIndices.size === 0) ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 active:scale-[0.98]'}`}>
                              {isProcessing ? (
                                <>
                                  <Loader2 className="animate-spin" size={20} />
                                  <span>{statusMessage || t.actions.processing}</span>
                                </>
                              ) : (
                                <>
                                  <Download size={18} />
                                  <span>{tool === 'convert' && t.actions.convertNow}{tool === 'merge' && t.actions.mergeNow}{tool === 'split' && t.actions.splitNow}{tool === 'reorder' && t.actions.saveOrder}</span>
                                </>
                              )}
                          </button>
                       </div>
                    </>
                  )}
                </div>
              </div>

              {/* PDF Viewer for Preview */}
              {activePreview && activePreview.type === 'pdf' && (
                   <div className="flex-1 flex flex-col items-center">
                     <div className="w-full max-w-md bg-gray-800 rounded-xl overflow-hidden shadow-2xl border border-gray-700 flex flex-col">
                        <div className="bg-gray-900 text-white p-3 flex justify-between items-center text-sm border-b border-gray-700">
                            <span className="truncate max-w-[200px]">{t.actions.preview}: {activePreview.file.name}</span>
                            <button onClick={() => setActivePreview(null)} className="hover:text-gray-300"><X size={16}/></button>
                        </div>
                        <div className="w-full aspect-a4 bg-gray-200 relative overflow-hidden">
                          <iframe src={activePreview.previewUrl + "#toolbar=0&view=FitH"} className="w-full h-full border-none" title="PDF Preview" />
                        </div>
                     </div>
                   </div>
              )}
            </div>
          </div>
        );
      };

      // --- 7. MAIN APP ---
      const App = () => {
        const [language, setLanguage] = useState('en');
        const [currentTool, setCurrentTool] = useState(null);
        const t = TRANSLATIONS[language];

        // Trigger font preload on mount
        useEffect(() => {
           loadCJKFont().catch(() => {});
        }, []);

        return (
          <div className="min-h-screen bg-slate-50 text-slate-900 font-sans selection:bg-blue-100 selection:text-blue-900">
            <TopBar language={language} setLanguage={setLanguage} title={t.title} />
            <main className="max-w-6xl mx-auto px-6 py-10">
              {!currentTool ? (
                <div className="flex flex-col gap-12 animate-fade-in">
                  <div className="text-center space-y-4 max-w-2xl mx-auto">
                    <h2 className="text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-600 to-indigo-600">{t.title}</h2>
                    <p className="text-lg text-slate-600 leading-relaxed">{t.subtitle}</p>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    {TOOLS_CONFIG.map((tool) => {
                      const Icon = tool.icon;
                      return (
                        <button key={tool.id} onClick={() => setCurrentTool(tool.id)} className="group relative bg-white rounded-2xl p-6 shadow-sm border border-gray-100 hover:shadow-xl hover:border-blue-100 transition-all duration-300 flex flex-col items-start text-left overflow-hidden">
                          <div className={`absolute top-0 right-0 w-24 h-24 ${tool.color} opacity-5 rounded-bl-full transition-transform group-hover:scale-110`} />
                          <div className={`w-12 h-12 rounded-xl ${tool.color} bg-opacity-10 flex items-center justify-center mb-4 group-hover:scale-110 transition-transform duration-300`}>
                            <Icon className={`w-6 h-6 ${tool.color.replace('bg-', 'text-')}`} />
                          </div>
                          <h3 className="text-lg font-bold text-gray-800 mb-2 group-hover:text-blue-600 transition-colors">{t.tools[tool.id]}</h3>
                          <div className="mt-auto flex items-center text-sm font-semibold text-gray-400 group-hover:text-blue-500 transition-colors">
                            Try Now <ArrowRight size={16} className="ml-1 opacity-0 -translate-x-2 group-hover:opacity-100 group-hover:translate-x-0 transition-all" />
                          </div>
                        </button>
                      );
                    })}
                  </div>
                  <div className="mt-12 text-center">
                    <span className="inline-flex items-center px-4 py-2 rounded-full bg-green-50 text-green-700 text-sm font-medium border border-green-100">
                      <span className="w-2 h-2 rounded-full bg-green-500 mr-2 animate-pulse"></span>
                      {t.footerSecure}
                    </span>
                  </div>
                </div>
              ) : (
                <div className="animate-in fade-in slide-in-from-bottom-4 duration-500">
                  <ToolWorkspace tool={currentTool} t={t} onBack={() => setCurrentTool(null)} />
                </div>
              )}
            </main>
          </div>
        );
      };

      // --- 8. ROOT RENDER ---
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>